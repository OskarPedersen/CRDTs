import all

class RoadGraph
  vertices : HashSet_int
  edges : ActiveHashMap_VertexPair_int
  neighbourMap : ActiveHashMap_int_List_int

  def init(numVertex : int) : void {
    this.vertices = new HashSet_int();
    repeat i <- numVertex {
      this.vertices.add(i);
    };
    this.edges = new ActiveHashMap_VertexPair_int();
    this.neighbourMap = new ActiveHashMap_int_List_int();
    let min = 0;
    let max = 1;
    let seed = 7894;
    let randomValues = randomSeq(numVertex * numVertex, min, max, seed);
    let randomInitial = randomSeq(numVertex, 0, numVertex - 1, 12845);

    repeat i <- numVertex { -- This makes the graph connected
      if (i != 0) then {
        let pair = new VertexPair(i, randomInitial[i] % i);
        this.addEdge(pair);
      }
    };
    repeat i <- numVertex { -- This adds some random edges (some may be duplicates)
      repeat j <- numVertex {
        let r = randomValues[i * numVertex + j];
        if ((i < j) and (r == 1)) then {
          let pair = new VertexPair(i, j);
          this.addEdge(pair);
        }
      }
    }
  }

  def addEdge(pair : VertexPair) : void {
    let initialEdgeWeight = 100;
    this.edges.put(pair, initialEdgeWeight);
    this.addNeighbour(pair.a, pair.b);
    this.addNeighbour(pair.b, pair.a);
  }

  def addNeighbour(vertex : int, neighbour : int) : void {
    let neighbourList = this.neighbourMap.getValue(vertex);
    if (neighbourList == null) then {
      neighbourList = new List_int();
      neighbourList.add(neighbour);
      this.neighbourMap.put(vertex)
    } else {
      neighbourList.add(neighbour); -- TODO will this work, or do we need to create a new copy of the list
    }
  }

  def getWeight(vp : VertexPair) : int {
    this.edges.getValue(vp);
  }

  def updateWeight(vp : VertexPair, newWeight : int) : void {
    this.edges.put(vp, newWeight);
  }


class ShortestPaths --TODO will this class be more than just an active hashmap?
  map : HashMap_FromTo_int
  -- TODO this could be just a matrix (almost entierly filled)
  def init() : void {
    this.map = new HashMap_FromTo_int();
  }

  def getNextVertex(current : int, goal : int) : int {
    let next = this.map.getValue(new FromTo(current, goal));
    next; -- TODO how to handle if no path has been created yet
  }

class UpdateQueue
  list : List_FromTo
  def init(numVertex : int) : void {
    repeat i <- numVertex {
      repeat j <- numVertex {
        if (i != j) then {
          this.push(new FromTo(i, j))
          -- TODO i j == j i,
          -- should we then only push one of them?
        }
      }
    }
  }

  def push(ft : FromTo) : void {
    this.list.add(ft)
  }

  def pop() : FromTo {
    let size = this.list.size();
    if (size > 0) then {
      let path = this.list.at(size - 1);
      this.list.remove(size - 1);
      path;
    } else {
      null : FromTo
    }
  }

class PathWorker
  numVertex : int
  def init(numVertex : int) : void {
    this.numVertex = numVertex
  }

  def start(updateQueue : UpdateQueue) : void {
    while (true) { -- how/when should this end?
      let ft = updateQueue.pop();
      if (ft == null) then {
        sleep(10); -- TODO what is best to do here?
      } else {
          this.calculatePath(ft)
      }
    }
  }

  def calculatePath(ft : FromTo, nextVertexMap : ActiveHashMap_FromTo_int,
      neighbourMap : ActiveHashMap_int_List_int) : void {
    let dist = new [int](this.numVertex);
    let prev = new [int](this.numVertex);
    let Q = new List_int();
    dist[ft.from] = 0;
    repeat i <- this.numVertex {
      if (i != ft.from) then {
        dist[i] = intMax();
        prev[i] = -1;
      };
      Q.add(i)
    };

    while (Q.size() > 0) {
      let min = intMax();
      let minVertex = -1;
      let minIndex = -1;
      repeat i <- Q.size() {
        if (dist[Q.at(i)] < min) then {
          min = dist[Q.at(i)];
          minVertex = Q.at(i);
          minIndex = i;
        }
      };
      Q.remove(minIndex);
      let neighbours = neighbourMap.getValue(minVertex);
      repeat i <- neighbours.size() {
        let alt = dist[minVertex] + map.getValue(new FromTo(minVertex, neighbours.get(i)));
        if (alt < dist[neighbours.get(i)]) then {
          dist[neighbours.get(i)] = alt;
          prev[neighbours.get(i)] = minVertex;
        }
      }
    };

    let c = ft.to;
    let p = prev[c]; -- TODO Will this get you the last before the goal? what if from and to are neighbours
    while (p != -1) {
      nextVertexMap.put(new FromTo(p, ft.to), c);
      nextVertexMap.put(new FromTo(c, ft.from), p); -- The reverse path
      p = c;
      c = prev[c];
    }
  }

class WeightHandler
  randomEdges : [VertexPair]
  randomWeightDeltas : [int]
  def init(numVertex : int, neighbourMap : ActiveHashMap_int_List_int) : void {
    let vertices = randomSeq(numVertex, 0, numVertex - 1, 8264);
    let neighbours = randomSeq(|vertices|, 0, intMax(), 9465);
    this.randomEdges = new [VertexPair](|vertices|);
    repeat i <- |vertices| {
      let nl =  neighbourMap.getValue(vertices[i]);
      randomEdges[i] = new VertexPair(vertices[i], nl.at(neighbours[i] % nl.size()));
    };

    let maxDelta = 50;
    let wd = randomSeq(20, 0, maxDelta * 2, 29036);
    randomWeightDeltas = new [int](|wd|);
    repeat i <- |wd| {
      randomWeightDeltas[i] = wd[i] - maxDelta;
    }
  }

  def start(roadGraph : RoadGraph, shortestPaths : ShortestPaths) : void {
    let randomEdgesIndex = 0;
    let randomWeightDeltasIndex = 0;
    while(true) { --TODO how/when to end this loop, ended by exit in main now
      sleep(50); -- TODO how much to sleep here
      let vp = randomEdges[i];
      let weight = roadGraph.getWeight(vp);
      if (weight != -1) then { --All edges should be valid
        --TODO add paths to update queue
        let delta = randomWeightDeltas[randomWeightDeltasIndex];
        roadGraph.updateWeight(vp, max(0, weight + delta));
        if (delta > 0) then {
          this.recomputePathsIncreased();
        } else if (delta < 0) then {
          this.recomputePathsDecreased();
        }
      } else {
        print("Non valid edge in start in WeightHandler");
      };

      randomEdgesIndex = randomEdgesIndex + 1;
      if (randomEdgesIndex >= |randomEdges|) then {
        randomEdgesIndex = 0;
      };

      randomWeightDeltasIndex = randomWeightDeltasIndex + 1;
      if (randomWeightDeltasIndex >= |randomWeightDeltas|) then {
        randomWeightDeltasIndex = 0;
      };
    }
  }

  def recomputePathsIncreased(vp : VertexPair) : void {
    repeat i <- numVertex {
      if (i != vp.a) then {
        if (shortestPaths.getNextVertex(vp.a, i) == vp.b) then {
          -- The path from a to i goes through b
          -- TODO this will NOT find the actual paths going through a to b
        }
      }
    };
    -- TODO do also for all the reverse paths
  }

  def recomputePathsDecreased(vp : VertexPair) : void {
    -- TODO recompute all paths except those already going through a - b
  }

class Car
  goal : int
  next : int
  current : int

  def init(start : int, next : int, goal : int) : void {
    this.current = start;
    this.next = next;
    this.goal = goal;
  }

  def travel(roadGraph : RoadGraph, shortestPaths : ShortestPaths) : bool {
    let goalReached = false;
    while (not goalReached) {
      let time = roadGraph.getWeight(this.current, this.next);
      if (time == -1) then {
        print("Bad edge in travel in Car. Current: {}, next: {}", this.current, this.next);
      } else {
        sleep(time);
      };
      this.current = this.next;
      if (this.current == this.goal) then {
        goalReached = true;
      } else {
        this.next = shortestPaths.getNextVertex(this.current, this.goal);
      }
    };
    true
  }

class Main {
  def main() : void {
    let numVertex = 5;
    let roadGraph = new RoadGraph(numVertex);
    let sp = new ShortestPaths();
    let uq = new UpdateQueue(numVertex);
    let wh = new WeightHandler();
    let pathWorkers = new [PathWorker](4);
    repeat i <- |pathWorkers| {
      pathWorkers[i] = new PathWorker();
    };
    let numCars = 10;
    let carFuts = new [Fut bool](numCars);
    let cars = new [Car](numCars);

    repeat i <- numCars {
      cars[i] = new Car(i % numVertex);
    };
    tic();
    wh.start();
    repeat i <- |pathWorkers| {
      (pathWorkers[i]).start();
    };
    repeat i <- numCars {
      carFuts[i] = (cars[i]).travel();
    };
    repeat i <- numCars {
      get carFuts[i];
    };
    let time = toc();
    print("Time: {}", time);
    embed void exit(EXIT_SUCCESS); end;

  }
}
