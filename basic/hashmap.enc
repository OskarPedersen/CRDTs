bundle hashmap where
passive class HashMapEntry_int_int
  key : int
  value : int

  def init(key : int, value : int) : void {
    this.key = key;
    this.value = value;
  }


passive class HashMap_int_int
  buckets : [List_HashMapEntry_int_int]
  loadFactor : real
  items : int

  def init() : void {
    this.buckets = new [List_HashMapEntry_int_int](10);
    this.loadFactor = 0.75;
    this.items = 0;
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_int_int();
    };
  }

  def put(key : int, value : int) : void {
    let bucket = this.hash(key);
    let exists = false;
    repeat i <- (this.buckets[bucket]).size() {
      if ( this.equal((this.buckets[bucket]).at(i).key, key)) then {
        exists = true;
        (this.buckets[bucket]).at(i).value = value;
        i = (this.buckets[bucket]).size() --break
      }
    };
    if (exists == false) then {
      (this.buckets[bucket]).add(new HashMapEntry_int_int(key, value));
      this.items = this.items + 1;
      if (this.items * this.loadFactor >= |this.buckets|) then {
        this.grow();
      }
    }
  }

  def getValue(key : int) : int {
    let
      bucket = this.hash(key)
      res = -1
    in {
      repeat i <- (this.buckets[bucket]).size() {
        if ( this.equal((this.buckets[bucket]).at(i).key, key))  then {
          res = (this.buckets[bucket]).at(i).value;
          i = (this.buckets[bucket]).size() --break
        }
      };
      res
    }
  }


  def grow() : void {
    let oldBuckets = this.buckets;
    this.buckets = new [List_HashMapEntry_int_int](|oldBuckets| * 2);
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_int_int();
    };
    this.items = 0;
    repeat b <- |oldBuckets| {
      repeat i <- (oldBuckets[b]).size() {
        let entry = (oldBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def equal(a : int, b : int) : bool {
    a == b
  }

  def toInt(a : int) : int {
    a
  }

  def hash(key : int) : int {
    this.toInt(key) % |this.buckets|

  }

  def getBuckets() : [List_HashMapEntry_int_int] {
    this.buckets
  }

  def putAll(hashMap : HashMap_int_int) : void {
    let otherBuckets = hashMap.getBuckets();
    repeat b <- |otherBuckets| {
      repeat i <- (otherBuckets[b]).size() {
        let entry = (otherBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def size() : int {
    this.items
  }

  def remove(key : int) : void {
    let bucket = this.hash(key);
    repeat i <- (this.buckets[bucket]).size() {
      if (this.equal((this.buckets[bucket]).at(i).key, key)) then {
        (this.buckets[bucket]).remove(i);
        this.items = this.items - 1;
        i = (this.buckets[bucket]).size() + 1 --break
      }
    }
  }

  def removeAll(keys : HashSet_int) : void {
    let iter = keys.iterator();
    let break = false;
    while (not break) {
      let key = iter.next();
      if (key == -1) then {
        break = true;
      } else {
        this.remove(key);
      }
    }
  }

  def iterator() : HashMapIterator_int_int {
    new HashMapIterator_int_int(this)
  }

passive class HashMapIterator_int_int
  hashMap : HashMap_int_int
  bucket : int
  i : int
  endReached : bool

  def init(hashMap : HashMap_int_int) : void {
    this.hashMap = hashMap;
    this.bucket = 0;
    this.i = -1;
    this.endReached = false;
  }

  def step() : void {
    let break = false;
    while (not break) {
      this.i = this.i + 1;
      if (this.i >= (this.hashMap.buckets[this.bucket]).size()) then {
        this.i = 0;
        this.bucket = this.bucket + 1;
        if (this.bucket >= |this.hashMap.buckets|) then {
          this.endReached = true;
          break = true;
        }
      };
      if ((not this.endReached)) then {
        if (this.i < (this.hashMap.buckets[this.bucket]).size()) then {
          break = true
        }
      }
    }
  }

  def next() : HashMapEntry_int_int {
    if (this.endReached) then {
      null : HashMapEntry_int_int
    } else {
      this.step();
      if (this.endReached) then {
        null : HashMapEntry_int_int
      } else {
        (this.hashMap.buckets[this.bucket]).at(this.i);
      }
    }
  }

class ActiveHashMap_int_int
  hashMap : HashMap_int_int

  def init() : void {
    this.hashMap = new HashMap_int_int()
  }

  def put(key : int, value : int) : void {
    this.hashMap.put(key, value)
  }

  def getValue(key : int) : int {
    this.hashMap.getValue(key)
  }


  def wait() : void {
    ()
  }

  def getBuckets() : [List_HashMapEntry_int_int] {
    this.hashMap.getBuckets()
  }

  def putAll(hashMap : HashMap_int_int) : void {
    this.hashMap.putAll(hashMap)
  }

  def size() : int {
    this.hashMap.size()
  }

  def remove(key : int) : void {
    this.hashMap.remove(key)
  }
passive class HashMapEntry_int_TimeOp
  key : int
  value : TimeOp

  def init(key : int, value : TimeOp) : void {
    this.key = key;
    this.value = value;
  }


passive class HashMap_int_TimeOp
  buckets : [List_HashMapEntry_int_TimeOp]
  loadFactor : real
  items : int

  def init() : void {
    this.buckets = new [List_HashMapEntry_int_TimeOp](10);
    this.loadFactor = 0.75;
    this.items = 0;
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_int_TimeOp();
    };
  }

  def put(key : int, value : TimeOp) : void {
    let bucket = this.hash(key);
    let exists = false;
    repeat i <- (this.buckets[bucket]).size() {
      if ( this.equal((this.buckets[bucket]).at(i).key, key)) then {
        exists = true;
        (this.buckets[bucket]).at(i).value = value;
        i = (this.buckets[bucket]).size() --break
      }
    };
    if (exists == false) then {
      (this.buckets[bucket]).add(new HashMapEntry_int_TimeOp(key, value));
      this.items = this.items + 1;
      if (this.items * this.loadFactor >= |this.buckets|) then {
        this.grow();
      }
    }
  }

  def getValue(key : int) : TimeOp {
    let
      bucket = this.hash(key)
      res = null : TimeOp
    in {
      repeat i <- (this.buckets[bucket]).size() {
        if ( this.equal((this.buckets[bucket]).at(i).key, key))  then {
          res = (this.buckets[bucket]).at(i).value;
          i = (this.buckets[bucket]).size() --break
        }
      };
      res
    }
  }


  def grow() : void {
    let oldBuckets = this.buckets;
    this.buckets = new [List_HashMapEntry_int_TimeOp](|oldBuckets| * 2);
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_int_TimeOp();
    };
    this.items = 0;
    repeat b <- |oldBuckets| {
      repeat i <- (oldBuckets[b]).size() {
        let entry = (oldBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def equal(a : int, b : int) : bool {
    a == b
  }

  def toInt(a : int) : int {
    a
  }

  def hash(key : int) : int {
    this.toInt(key) % |this.buckets|

  }

  def getBuckets() : [List_HashMapEntry_int_TimeOp] {
    this.buckets
  }

  def putAll(hashMap : HashMap_int_TimeOp) : void {
    let otherBuckets = hashMap.getBuckets();
    repeat b <- |otherBuckets| {
      repeat i <- (otherBuckets[b]).size() {
        let entry = (otherBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def size() : int {
    this.items
  }

  def remove(key : int) : void {
    let bucket = this.hash(key);
    repeat i <- (this.buckets[bucket]).size() {
      if (this.equal((this.buckets[bucket]).at(i).key, key)) then {
        (this.buckets[bucket]).remove(i);
        this.items = this.items - 1;
        i = (this.buckets[bucket]).size() + 1 --break
      }
    }
  }

  def removeAll(keys : HashSet_int) : void {
    let iter = keys.iterator();
    let break = false;
    while (not break) {
      let key = iter.next();
      if (key == -1) then {
        break = true;
      } else {
        this.remove(key);
      }
    }
  }

  def iterator() : HashMapIterator_int_TimeOp {
    new HashMapIterator_int_TimeOp(this)
  }

passive class HashMapIterator_int_TimeOp
  hashMap : HashMap_int_TimeOp
  bucket : int
  i : int
  endReached : bool

  def init(hashMap : HashMap_int_TimeOp) : void {
    this.hashMap = hashMap;
    this.bucket = 0;
    this.i = -1;
    this.endReached = false;
  }

  def step() : void {
    let break = false;
    while (not break) {
      this.i = this.i + 1;
      if (this.i >= (this.hashMap.buckets[this.bucket]).size()) then {
        this.i = 0;
        this.bucket = this.bucket + 1;
        if (this.bucket >= |this.hashMap.buckets|) then {
          this.endReached = true;
          break = true;
        }
      };
      if ((not this.endReached)) then {
        if (this.i < (this.hashMap.buckets[this.bucket]).size()) then {
          break = true
        }
      }
    }
  }

  def next() : HashMapEntry_int_TimeOp {
    if (this.endReached) then {
      null : HashMapEntry_int_TimeOp
    } else {
      this.step();
      if (this.endReached) then {
        null : HashMapEntry_int_TimeOp
      } else {
        (this.hashMap.buckets[this.bucket]).at(this.i);
      }
    }
  }

class ActiveHashMap_int_TimeOp
  hashMap : HashMap_int_TimeOp

  def init() : void {
    this.hashMap = new HashMap_int_TimeOp()
  }

  def put(key : int, value : TimeOp) : void {
    this.hashMap.put(key, value)
  }

  def getValue(key : int) : TimeOp {
    this.hashMap.getValue(key)
  }


  def wait() : void {
    ()
  }

  def getBuckets() : [List_HashMapEntry_int_TimeOp] {
    this.hashMap.getBuckets()
  }

  def putAll(hashMap : HashMap_int_TimeOp) : void {
    this.hashMap.putAll(hashMap)
  }

  def size() : int {
    this.hashMap.size()
  }

  def remove(key : int) : void {
    this.hashMap.remove(key)
  }
passive class HashMapEntry_int_HashSet_int
  key : int
  value : HashSet_int

  def init(key : int, value : HashSet_int) : void {
    this.key = key;
    this.value = value;
  }


passive class HashMap_int_HashSet_int
  buckets : [List_HashMapEntry_int_HashSet_int]
  loadFactor : real
  items : int

  def init() : void {
    this.buckets = new [List_HashMapEntry_int_HashSet_int](10);
    this.loadFactor = 0.75;
    this.items = 0;
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_int_HashSet_int();
    };
  }

  def put(key : int, value : HashSet_int) : void {
    let bucket = this.hash(key);
    let exists = false;
    repeat i <- (this.buckets[bucket]).size() {
      if ( this.equal((this.buckets[bucket]).at(i).key, key)) then {
        exists = true;
        (this.buckets[bucket]).at(i).value = value;
        i = (this.buckets[bucket]).size() --break
      }
    };
    if (exists == false) then {
      (this.buckets[bucket]).add(new HashMapEntry_int_HashSet_int(key, value));
      this.items = this.items + 1;
      if (this.items * this.loadFactor >= |this.buckets|) then {
        this.grow();
      }
    }
  }

  def getValue(key : int) : HashSet_int {
    let
      bucket = this.hash(key)
      res = null : HashSet_int
    in {
      repeat i <- (this.buckets[bucket]).size() {
        if ( this.equal((this.buckets[bucket]).at(i).key, key))  then {
          res = (this.buckets[bucket]).at(i).value;
          i = (this.buckets[bucket]).size() --break
        }
      };
      res
    }
  }


  def grow() : void {
    let oldBuckets = this.buckets;
    this.buckets = new [List_HashMapEntry_int_HashSet_int](|oldBuckets| * 2);
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_int_HashSet_int();
    };
    this.items = 0;
    repeat b <- |oldBuckets| {
      repeat i <- (oldBuckets[b]).size() {
        let entry = (oldBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def equal(a : int, b : int) : bool {
    a == b
  }

  def toInt(a : int) : int {
    a
  }

  def hash(key : int) : int {
    this.toInt(key) % |this.buckets|

  }

  def getBuckets() : [List_HashMapEntry_int_HashSet_int] {
    this.buckets
  }

  def putAll(hashMap : HashMap_int_HashSet_int) : void {
    let otherBuckets = hashMap.getBuckets();
    repeat b <- |otherBuckets| {
      repeat i <- (otherBuckets[b]).size() {
        let entry = (otherBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def size() : int {
    this.items
  }

  def remove(key : int) : void {
    let bucket = this.hash(key);
    repeat i <- (this.buckets[bucket]).size() {
      if (this.equal((this.buckets[bucket]).at(i).key, key)) then {
        (this.buckets[bucket]).remove(i);
        this.items = this.items - 1;
        i = (this.buckets[bucket]).size() + 1 --break
      }
    }
  }

  def removeAll(keys : HashSet_int) : void {
    let iter = keys.iterator();
    let break = false;
    while (not break) {
      let key = iter.next();
      if (key == -1) then {
        break = true;
      } else {
        this.remove(key);
      }
    }
  }

  def iterator() : HashMapIterator_int_HashSet_int {
    new HashMapIterator_int_HashSet_int(this)
  }

passive class HashMapIterator_int_HashSet_int
  hashMap : HashMap_int_HashSet_int
  bucket : int
  i : int
  endReached : bool

  def init(hashMap : HashMap_int_HashSet_int) : void {
    this.hashMap = hashMap;
    this.bucket = 0;
    this.i = -1;
    this.endReached = false;
  }

  def step() : void {
    let break = false;
    while (not break) {
      this.i = this.i + 1;
      if (this.i >= (this.hashMap.buckets[this.bucket]).size()) then {
        this.i = 0;
        this.bucket = this.bucket + 1;
        if (this.bucket >= |this.hashMap.buckets|) then {
          this.endReached = true;
          break = true;
        }
      };
      if ((not this.endReached)) then {
        if (this.i < (this.hashMap.buckets[this.bucket]).size()) then {
          break = true
        }
      }
    }
  }

  def next() : HashMapEntry_int_HashSet_int {
    if (this.endReached) then {
      null : HashMapEntry_int_HashSet_int
    } else {
      this.step();
      if (this.endReached) then {
        null : HashMapEntry_int_HashSet_int
      } else {
        (this.hashMap.buckets[this.bucket]).at(this.i);
      }
    }
  }

class ActiveHashMap_int_HashSet_int
  hashMap : HashMap_int_HashSet_int

  def init() : void {
    this.hashMap = new HashMap_int_HashSet_int()
  }

  def put(key : int, value : HashSet_int) : void {
    this.hashMap.put(key, value)
  }

  def getValue(key : int) : HashSet_int {
    this.hashMap.getValue(key)
  }


  def wait() : void {
    ()
  }

  def getBuckets() : [List_HashMapEntry_int_HashSet_int] {
    this.hashMap.getBuckets()
  }

  def putAll(hashMap : HashMap_int_HashSet_int) : void {
    this.hashMap.putAll(hashMap)
  }

  def size() : int {
    this.hashMap.size()
  }

  def remove(key : int) : void {
    this.hashMap.remove(key)
  }
passive class HashMapEntry_NodeID_RGANode
  key : NodeID
  value : RGANode

  def init(key : NodeID, value : RGANode) : void {
    this.key = key;
    this.value = value;
  }


passive class HashMap_NodeID_RGANode
  buckets : [List_HashMapEntry_NodeID_RGANode]
  loadFactor : real
  items : int

  def init() : void {
    this.buckets = new [List_HashMapEntry_NodeID_RGANode](10);
    this.loadFactor = 0.75;
    this.items = 0;
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_NodeID_RGANode();
    };
  }

  def put(key : NodeID, value : RGANode) : void {
    let bucket = this.hash(key);
    let exists = false;
    repeat i <- (this.buckets[bucket]).size() {
      if ( this.equal((this.buckets[bucket]).at(i).key, key)) then {
        exists = true;
        (this.buckets[bucket]).at(i).value = value;
        i = (this.buckets[bucket]).size() --break
      }
    };
    if (exists == false) then {
      (this.buckets[bucket]).add(new HashMapEntry_NodeID_RGANode(key, value));
      this.items = this.items + 1;
      if (this.items * this.loadFactor >= |this.buckets|) then {
        this.grow();
      }
    }
  }

  def getValue(key : NodeID) : RGANode {
    let
      bucket = this.hash(key)
      res = null : RGANode
    in {
      repeat i <- (this.buckets[bucket]).size() {
        if ( this.equal((this.buckets[bucket]).at(i).key, key))  then {
          res = (this.buckets[bucket]).at(i).value;
          i = (this.buckets[bucket]).size() --break
        }
      };
      res
    }
  }


  def grow() : void {
    let oldBuckets = this.buckets;
    this.buckets = new [List_HashMapEntry_NodeID_RGANode](|oldBuckets| * 2);
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_NodeID_RGANode();
    };
    this.items = 0;
    repeat b <- |oldBuckets| {
      repeat i <- (oldBuckets[b]).size() {
        let entry = (oldBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def equal(a : NodeID, b : NodeID) : bool {
    a.equals(b)
  }

  def toInt(a : NodeID) : int {
    a.toInt()
  }

  def hash(key : NodeID) : int {
    this.toInt(key) % |this.buckets|

  }

  def getBuckets() : [List_HashMapEntry_NodeID_RGANode] {
    this.buckets
  }

  def putAll(hashMap : HashMap_NodeID_RGANode) : void {
    let otherBuckets = hashMap.getBuckets();
    repeat b <- |otherBuckets| {
      repeat i <- (otherBuckets[b]).size() {
        let entry = (otherBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def size() : int {
    this.items
  }

  def remove(key : NodeID) : void {
    let bucket = this.hash(key);
    repeat i <- (this.buckets[bucket]).size() {
      if (this.equal((this.buckets[bucket]).at(i).key, key)) then {
        (this.buckets[bucket]).remove(i);
        this.items = this.items - 1;
        i = (this.buckets[bucket]).size() + 1 --break
      }
    }
  }

  def removeAll(keys : HashSet_NodeID) : void {
    let iter = keys.iterator();
    let break = false;
    while (not break) {
      let key = iter.next();
      if (key == null) then {
        break = true;
      } else {
        this.remove(key);
      }
    }
  }

  def iterator() : HashMapIterator_NodeID_RGANode {
    new HashMapIterator_NodeID_RGANode(this)
  }

passive class HashMapIterator_NodeID_RGANode
  hashMap : HashMap_NodeID_RGANode
  bucket : int
  i : int
  endReached : bool

  def init(hashMap : HashMap_NodeID_RGANode) : void {
    this.hashMap = hashMap;
    this.bucket = 0;
    this.i = -1;
    this.endReached = false;
  }

  def step() : void {
    let break = false;
    while (not break) {
      this.i = this.i + 1;
      if (this.i >= (this.hashMap.buckets[this.bucket]).size()) then {
        this.i = 0;
        this.bucket = this.bucket + 1;
        if (this.bucket >= |this.hashMap.buckets|) then {
          this.endReached = true;
          break = true;
        }
      };
      if ((not this.endReached)) then {
        if (this.i < (this.hashMap.buckets[this.bucket]).size()) then {
          break = true
        }
      }
    }
  }

  def next() : HashMapEntry_NodeID_RGANode {
    if (this.endReached) then {
      null : HashMapEntry_NodeID_RGANode
    } else {
      this.step();
      if (this.endReached) then {
        null : HashMapEntry_NodeID_RGANode
      } else {
        (this.hashMap.buckets[this.bucket]).at(this.i);
      }
    }
  }

class ActiveHashMap_NodeID_RGANode
  hashMap : HashMap_NodeID_RGANode

  def init() : void {
    this.hashMap = new HashMap_NodeID_RGANode()
  }

  def put(key : NodeID, value : RGANode) : void {
    this.hashMap.put(key, value)
  }

  def getValue(key : NodeID) : RGANode {
    this.hashMap.getValue(key)
  }


  def wait() : void {
    ()
  }

  def getBuckets() : [List_HashMapEntry_NodeID_RGANode] {
    this.hashMap.getBuckets()
  }

  def putAll(hashMap : HashMap_NodeID_RGANode) : void {
    this.hashMap.putAll(hashMap)
  }

  def size() : int {
    this.hashMap.size()
  }

  def remove(key : NodeID) : void {
    this.hashMap.remove(key)
  }
passive class HashMapEntry_NodeID_int
  key : NodeID
  value : int

  def init(key : NodeID, value : int) : void {
    this.key = key;
    this.value = value;
  }


passive class HashMap_NodeID_int
  buckets : [List_HashMapEntry_NodeID_int]
  loadFactor : real
  items : int

  def init() : void {
    this.buckets = new [List_HashMapEntry_NodeID_int](10);
    this.loadFactor = 0.75;
    this.items = 0;
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_NodeID_int();
    };
  }

  def put(key : NodeID, value : int) : void {
    let bucket = this.hash(key);
    let exists = false;
    repeat i <- (this.buckets[bucket]).size() {
      if ( this.equal((this.buckets[bucket]).at(i).key, key)) then {
        exists = true;
        (this.buckets[bucket]).at(i).value = value;
        i = (this.buckets[bucket]).size() --break
      }
    };
    if (exists == false) then {
      (this.buckets[bucket]).add(new HashMapEntry_NodeID_int(key, value));
      this.items = this.items + 1;
      if (this.items * this.loadFactor >= |this.buckets|) then {
        this.grow();
      }
    }
  }

  def getValue(key : NodeID) : int {
    let
      bucket = this.hash(key)
      res = -1
    in {
      repeat i <- (this.buckets[bucket]).size() {
        if ( this.equal((this.buckets[bucket]).at(i).key, key))  then {
          res = (this.buckets[bucket]).at(i).value;
          i = (this.buckets[bucket]).size() --break
        }
      };
      res
    }
  }


  def grow() : void {
    let oldBuckets = this.buckets;
    this.buckets = new [List_HashMapEntry_NodeID_int](|oldBuckets| * 2);
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_NodeID_int();
    };
    this.items = 0;
    repeat b <- |oldBuckets| {
      repeat i <- (oldBuckets[b]).size() {
        let entry = (oldBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def equal(a : NodeID, b : NodeID) : bool {
    a.equals(b)
  }

  def toInt(a : NodeID) : int {
    a.toInt()
  }

  def hash(key : NodeID) : int {
    this.toInt(key) % |this.buckets|

  }

  def getBuckets() : [List_HashMapEntry_NodeID_int] {
    this.buckets
  }

  def putAll(hashMap : HashMap_NodeID_int) : void {
    let otherBuckets = hashMap.getBuckets();
    repeat b <- |otherBuckets| {
      repeat i <- (otherBuckets[b]).size() {
        let entry = (otherBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def size() : int {
    this.items
  }

  def remove(key : NodeID) : void {
    let bucket = this.hash(key);
    repeat i <- (this.buckets[bucket]).size() {
      if (this.equal((this.buckets[bucket]).at(i).key, key)) then {
        (this.buckets[bucket]).remove(i);
        this.items = this.items - 1;
        i = (this.buckets[bucket]).size() + 1 --break
      }
    }
  }

  def removeAll(keys : HashSet_NodeID) : void {
    let iter = keys.iterator();
    let break = false;
    while (not break) {
      let key = iter.next();
      if (key == null) then {
        break = true;
      } else {
        this.remove(key);
      }
    }
  }

  def iterator() : HashMapIterator_NodeID_int {
    new HashMapIterator_NodeID_int(this)
  }

passive class HashMapIterator_NodeID_int
  hashMap : HashMap_NodeID_int
  bucket : int
  i : int
  endReached : bool

  def init(hashMap : HashMap_NodeID_int) : void {
    this.hashMap = hashMap;
    this.bucket = 0;
    this.i = -1;
    this.endReached = false;
  }

  def step() : void {
    let break = false;
    while (not break) {
      this.i = this.i + 1;
      if (this.i >= (this.hashMap.buckets[this.bucket]).size()) then {
        this.i = 0;
        this.bucket = this.bucket + 1;
        if (this.bucket >= |this.hashMap.buckets|) then {
          this.endReached = true;
          break = true;
        }
      };
      if ((not this.endReached)) then {
        if (this.i < (this.hashMap.buckets[this.bucket]).size()) then {
          break = true
        }
      }
    }
  }

  def next() : HashMapEntry_NodeID_int {
    if (this.endReached) then {
      null : HashMapEntry_NodeID_int
    } else {
      this.step();
      if (this.endReached) then {
        null : HashMapEntry_NodeID_int
      } else {
        (this.hashMap.buckets[this.bucket]).at(this.i);
      }
    }
  }

class ActiveHashMap_NodeID_int
  hashMap : HashMap_NodeID_int

  def init() : void {
    this.hashMap = new HashMap_NodeID_int()
  }

  def put(key : NodeID, value : int) : void {
    this.hashMap.put(key, value)
  }

  def getValue(key : NodeID) : int {
    this.hashMap.getValue(key)
  }


  def wait() : void {
    ()
  }

  def getBuckets() : [List_HashMapEntry_NodeID_int] {
    this.hashMap.getBuckets()
  }

  def putAll(hashMap : HashMap_NodeID_int) : void {
    this.hashMap.putAll(hashMap)
  }

  def size() : int {
    this.hashMap.size()
  }

  def remove(key : NodeID) : void {
    this.hashMap.remove(key)
  }
passive class HashMapEntry_VertexPair_int
  key : VertexPair
  value : int

  def init(key : VertexPair, value : int) : void {
    this.key = key;
    this.value = value;
  }


passive class HashMap_VertexPair_int
  buckets : [List_HashMapEntry_VertexPair_int]
  loadFactor : real
  items : int

  def init() : void {
    this.buckets = new [List_HashMapEntry_VertexPair_int](10);
    this.loadFactor = 0.75;
    this.items = 0;
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_VertexPair_int();
    };
  }

  def put(key : VertexPair, value : int) : void {
    let bucket = this.hash(key);
    let exists = false;
    repeat i <- (this.buckets[bucket]).size() {
      if ( this.equal((this.buckets[bucket]).at(i).key, key)) then {
        exists = true;
        (this.buckets[bucket]).at(i).value = value;
        i = (this.buckets[bucket]).size() --break
      }
    };
    if (exists == false) then {
      (this.buckets[bucket]).add(new HashMapEntry_VertexPair_int(key, value));
      this.items = this.items + 1;
      if (this.items * this.loadFactor >= |this.buckets|) then {
        this.grow();
      }
    }
  }

  def getValue(key : VertexPair) : int {
    let
      bucket = this.hash(key)
      res = -1
    in {
      repeat i <- (this.buckets[bucket]).size() {
        if ( this.equal((this.buckets[bucket]).at(i).key, key))  then {
          res = (this.buckets[bucket]).at(i).value;
          i = (this.buckets[bucket]).size() --break
        }
      };
      res
    }
  }


  def grow() : void {
    let oldBuckets = this.buckets;
    this.buckets = new [List_HashMapEntry_VertexPair_int](|oldBuckets| * 2);
    repeat i <- |this.buckets| {
      this.buckets[i] = new List_HashMapEntry_VertexPair_int();
    };
    this.items = 0;
    repeat b <- |oldBuckets| {
      repeat i <- (oldBuckets[b]).size() {
        let entry = (oldBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def equal(a : VertexPair, b : VertexPair) : bool {
    a.equals(b)
  }

  def toInt(a : VertexPair) : int {
    a.toInt()
  }

  def hash(key : VertexPair) : int {
    this.toInt(key) % |this.buckets|

  }

  def getBuckets() : [List_HashMapEntry_VertexPair_int] {
    this.buckets
  }

  def putAll(hashMap : HashMap_VertexPair_int) : void {
    let otherBuckets = hashMap.getBuckets();
    repeat b <- |otherBuckets| {
      repeat i <- (otherBuckets[b]).size() {
        let entry = (otherBuckets[b]).at(i);
        this.put(entry.key, entry.value);
      }
    }
  }

  def size() : int {
    this.items
  }

  def remove(key : VertexPair) : void {
    let bucket = this.hash(key);
    repeat i <- (this.buckets[bucket]).size() {
      if (this.equal((this.buckets[bucket]).at(i).key, key)) then {
        (this.buckets[bucket]).remove(i);
        this.items = this.items - 1;
        i = (this.buckets[bucket]).size() + 1 --break
      }
    }
  }

  def removeAll(keys : HashSet_VertexPair) : void {
    let iter = keys.iterator();
    let break = false;
    while (not break) {
      let key = iter.next();
      if (key == null) then {
        break = true;
      } else {
        this.remove(key);
      }
    }
  }

  def iterator() : HashMapIterator_VertexPair_int {
    new HashMapIterator_VertexPair_int(this)
  }

passive class HashMapIterator_VertexPair_int
  hashMap : HashMap_VertexPair_int
  bucket : int
  i : int
  endReached : bool

  def init(hashMap : HashMap_VertexPair_int) : void {
    this.hashMap = hashMap;
    this.bucket = 0;
    this.i = -1;
    this.endReached = false;
  }

  def step() : void {
    let break = false;
    while (not break) {
      this.i = this.i + 1;
      if (this.i >= (this.hashMap.buckets[this.bucket]).size()) then {
        this.i = 0;
        this.bucket = this.bucket + 1;
        if (this.bucket >= |this.hashMap.buckets|) then {
          this.endReached = true;
          break = true;
        }
      };
      if ((not this.endReached)) then {
        if (this.i < (this.hashMap.buckets[this.bucket]).size()) then {
          break = true
        }
      }
    }
  }

  def next() : HashMapEntry_VertexPair_int {
    if (this.endReached) then {
      null : HashMapEntry_VertexPair_int
    } else {
      this.step();
      if (this.endReached) then {
        null : HashMapEntry_VertexPair_int
      } else {
        (this.hashMap.buckets[this.bucket]).at(this.i);
      }
    }
  }

class ActiveHashMap_VertexPair_int
  hashMap : HashMap_VertexPair_int

  def init() : void {
    this.hashMap = new HashMap_VertexPair_int()
  }

  def put(key : VertexPair, value : int) : void {
    this.hashMap.put(key, value)
  }

  def getValue(key : VertexPair) : int {
    this.hashMap.getValue(key)
  }


  def wait() : void {
    ()
  }

  def getBuckets() : [List_HashMapEntry_VertexPair_int] {
    this.hashMap.getBuckets()
  }

  def putAll(hashMap : HashMap_VertexPair_int) : void {
    this.hashMap.putAll(hashMap)
  }

  def size() : int {
    this.hashMap.size()
  }

  def remove(key : VertexPair) : void {
    this.hashMap.remove(key)
  }
